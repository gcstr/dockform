version: '3'

vars:
  GO: '{{.ENV.GO | default "go"}}'
  PKGS: '{{.ENV.PKGS | default "./internal/... ./cmd/..."}}'
  E2E_PKGS: '{{.ENV.E2E_PKGS | default "./test/e2e"}}'
  MAIN: '{{.ENV.MAIN | default "./cmd/dockform"}}'
  BIN: '{{.ENV.BIN | default "dockform"}}'
  COVER_OUT: '{{.ENV.COVER_OUT | default "cover.out"}}'
  GOLANGCI_LINT_PKG: '{{.ENV.GOLANGCI_LINT_PKG | default "github.com/golangci/golangci-lint/cmd/golangci-lint@latest"}}'
  GOLANGCI_LINT_VERSION: '{{.ENV.GOLANGCI_LINT_VERSION | default "v2.5.0"}}'
  ARGS: '{{.ENV.ARGS | default ""}}'
  CURRENT_TAG: 
    sh: git describe --abbrev=0 --tags

tasks:
  default:
    desc: Show available tasks
    silent: true
    cmds:
      - task --list

  help:
    desc: Show available tasks
    silent: true
    cmds:
      - task --list

  all:
    desc: Format, vet, test, and build
    cmds:
      - task: fmt
      - task: vet
      - task: test
      - task: build

  build:
    desc: Build the dockform binary
    cmds:
      - '{{.GO}} build -o {{.BIN}} {{.MAIN}}'

  run:
    desc: Run the dockform CLI (pass ARGS="..." to forward args)
    cmds:
      - '{{.GO}} run {{.MAIN}} {{.ARGS}}'

  install:
    desc: Install the dockform binary to GOPATH/bin
    cmds:
      - '{{.GO}} install {{.MAIN}}'

  fmt:
    desc: Format code
    cmds:
      - '{{.GO}} fmt {{.PKGS}}'

  vet:
    desc: Run go vet
    cmds:
      - '{{.GO}} vet {{.PKGS}}'

  lint:
    desc: Run golangci-lint v2
    cmds:
      - cmd: |
          set -euo pipefail
          if ! command -v golangci-lint >/dev/null 2>&1 || ! golangci-lint --version 2>&1 | grep -q "version 2"; then
            echo "Installing golangci-lint {{.GOLANGCI_LINT_VERSION}} to $(go env GOPATH)/bin"
            curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- {{.GOLANGCI_LINT_VERSION}} -b $(go env GOPATH)/bin
          fi
          PATH=$(go env GOPATH)/bin:$PATH golangci-lint run
        silent: true

  lint:refresh:
    desc: Force (re)install golangci-lint v2 and run
    cmds:
      - cmd: |
          set -euo pipefail
          echo "Reinstalling golangci-lint {{.GOLANGCI_LINT_VERSION}} to $(go env GOPATH)/bin"
          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- {{.GOLANGCI_LINT_VERSION}} -b $(go env GOPATH)/bin
          PATH=$(go env GOPATH)/bin:$PATH golangci-lint run
        silent: true

  deps:
    desc: Download go module dependencies
    cmds:
      - '{{.GO}} mod download'

  tidy:
    desc: Tidy go.mod/go.sum
    cmds:
      - '{{.GO}} mod tidy'

  test:
    desc: Run tests with coverage
    deps: [vet]
    cmds:
      - '{{.GO}} run gotest.tools/gotestsum@latest {{.PKGS}} -- -count=1 -coverprofile={{.COVER_OUT}}'

  e2e:
    desc: Run end-to-end tests
    cmds:
      - '{{.GO}} run gotest.tools/gotestsum@latest --format testname {{.E2E_PKGS}} -- -count=1 -v'

  coverage:
    desc: Show coverage summary (requires {{.COVER_OUT}})
    cmds:
      - '{{.GO}} run gotest.tools/gotestsum@latest -- -coverprofile={{.COVER_OUT}} {{.PKGS}}'

  coverage:total:
    desc: Run tests with coverage across packages and print total coverage percent
    cmds:
      - cmd: |
          set -euo pipefail
          # Expand PKGS into a comma-separated list for -coverpkg
          # PKGS may contain spaces; convert to comma list and strip ./ prefixes for clarity
          PKGS_CSV=$(echo "{{.PKGS}}" | tr -s ' ' ',' )
          echo "Running tests for packages: {{.PKGS}}"
          {{.GO}} test -covermode=count -coverpkg="$PKGS_CSV" -coverprofile={{.COVER_OUT}} ./...
          echo "Total coverage:" \
            $( {{.GO}} tool cover -func={{.COVER_OUT}} | grep '^total:' | awk '{print $3}' )
        silent: true

  coverhtml:
    desc: Generate HTML coverage report at cover.html
    cmds:
      - '{{.GO}} tool cover -html={{.COVER_OUT}} -o cover.html'

  ci:
    desc: Lint, test, and run e2e (mirror CI pipeline locally)
    cmds:
      - task: lint
      - task: test
      - task: e2e

  clean:
    desc: Remove build artifacts
    cmds:
      - rm -f '{{.BIN}}' '{{.COVER_OUT}}' cover.html

  release:check:
    desc: Validate GoReleaser configuration
    cmds:
      - '{{.GO}} run github.com/goreleaser/goreleaser/v2@latest check'

  release:snapshot:
    desc: Build release artifacts locally without publishing
    cmds:
      - '{{.GO}} run github.com/goreleaser/goreleaser/v2@latest release --clean --skip=publish --snapshot'

  release:publish:
    desc: Create a GitHub Release for the current tag using GoReleaser (manually publish on GitHub)
    cmds:
      - '{{.GO}} run github.com/goreleaser/goreleaser/v2@latest release --clean'

  docs:cli:
    desc: Generate CLI docs from Cobra into docs/cli
    cmds:
      - '{{.GO}} run -tags dev {{.MAIN}} docs --out docs/cli'

  release:tag:
    desc: Intefactively create a new tag and push it to the remote repository
    cmds:
      - cmd: |
          CURRENT_BRANCH=$(git branch --show-current)
          if [ "$CURRENT_BRANCH" != "main" ]; then
            echo "Error: must be on main branch to create a release tag (currently on $CURRENT_BRANCH)"
            exit 1
          fi
        silent: true
      - cmd: gum style --border normal --margin "1" --padding "1 2" --border-foreground 212 "Current tag -> $(gum style --foreground 212 '{{.CURRENT_TAG}}')"
        silent: true
      - cmd: |
          set -e
          NEW_TAG=$(gum input --placeholder "New tag")
          gum confirm "Create tag $NEW_TAG?" || exit 1
          echo "Creating tag $NEW_TAG"
          git tag -a $NEW_TAG -m "release $NEW_TAG"
          gum confirm "Push tag $NEW_TAG?" || exit 1
          git push origin $NEW_TAG
        silent: true


      